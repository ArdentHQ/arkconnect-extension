/* eslint-disable */
import * as fs from 'fs';
import * as path from 'path';
import * as SVGO from 'svgo';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const iconsPath = path.join(__dirname, '../src/assets/icons');
const iconComponentPath = path.join(__dirname, '../src/shared/components/icon/index.generated.tsx');
const plugins = [
  'cleanupAttrs',
  'cleanupNumericValues',
  'collapseGroups',
  'convertColors',
  'convertPathData',
  'convertShapeToPath',
  'convertStyleToAttrs',
  'convertTransform',
  'mergePaths',
  'moveElemsAttrsToGroup',
  'moveGroupAttrsToElems',
  'removeComments',
  'removeDesc',
  'removeDimensions',
  'removeDoctype',
  'removeEditorsNSData',
  'removeEmptyAttrs',
  'removeEmptyContainers',
  'removeEmptyText',
  'removeHiddenElems',
  'removeMetadata',
  'removeNonInheritableGroupAttrs',
  'removeTitle',
  'removeUnknownsAndDefaults',
  'removeUnusedNS',
  'removeUselessDefs',
  'removeUselessStrokeAndFill',
  'removeXMLProcInst',
  'sortAttrs',
];

function replaceKebabWithCamel(svgString) {
  const attributeRegex = /(\S+)="([^"]*)"/g;

  return svgString.replace(attributeRegex, (match, attributeName, attributeValue) => {
    const camelCaseAttrName = attributeName.replace(/-(\w)/g, (_, letter) => letter.toUpperCase());
    return `${camelCaseAttrName}="${attributeValue}"`;
  });
}

async function run() {
  /**
   *
   * First step, process each individual SVG file
   *
   */

  const icons = [];
  const iconFiles = fs.readdirSync(iconsPath).filter((f) => f[0] !== '.');
  let result = { processed: [], errors: [] };
  for (const i in iconFiles) {
    const iconFileName = iconFiles[i];
    try {
      if (!iconFileName.match(/\.svg$/)) {
        throw new Error(`Only *.svg files allowed`);
      }
      const iconFileData = fs.readFileSync(path.resolve(iconsPath, iconFileName));
      let svg;

      try {
        svg = SVGO.optimize(iconFileData, {
          path: iconFileName,
          plugins,
        });
      } catch (error) {
        throw new Error(`Cannot process SVG content`);
      }
      if (!svg || !svg.data || svg.data.length === 0) {
        throw new Error(`No SVG content`);
      }
      icons.push({
        icon: iconFileName.slice(0, -4),
        filename: iconFileName,
        svg: replaceKebabWithCamel(svg.data.replace('class', 'className')),
      });
      result.processed.push(iconFileName);
    } catch (error) {
      result.errors.push(`${iconFileName}: ${error.message}`);
    }
  }
  console.log('add-icons script completed. Result:', result);
  if (result.errors.length > 0) {
    process.exit(1);
  }
  /**
   *
   * Second step, generate React code
   *
   */
  const iconComponent = [
    `//\n`,
    `// WARNING\n`,
    `//\n`,
    `// Do not make manual changes to this file.\n`,
    `// This file was generated by generate-icons.js.\n`,
    `//\n`,
    `//\n`,
    `\n\n`,
    `/**\n`,
    ` * A list of all available icons in the icon set.\n`,
    ` */\n`,
    'export type IconDefinition = ',
    icons.map((i) => `'${i.icon}'`).join(' | '),
    `;\n\n`,
    `export const availableIcons: IconDefinition[] = [`,
    icons.map((i) => `'${i.icon}'`).join(', '),
    `];\n\n`,
    `export const IconSvg = {\n`,
    icons.map((i) => `  '${i.icon}': ${i.svg},\n`).join(''),
    `};\n`,
  ];
  fs.writeFileSync(iconComponentPath, iconComponent.join(''));
}
run();
